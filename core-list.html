<!--
Copyright (c) 2014 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
-->

<!--
`core-list` displays a virtual, 'infinite' list. The template inside the 
`core-list` element represents the dom to create for each list item. The
`data` property specifies an array of list item data. The `height` property
represents the fixed height of a list item (variable height list items are
not supported).

`core-list` manages a viewport of data based on the current scroll position.
For performance reasons, not every item in the list is rendered at once.

List item templates should bind to template models of the following structure

    {
      index: 0,         // list index for this item
      selected: false,  // selection state for this item
      model: {          // user data corresponding to data[index]
        /* user data  */
      }
    }

For example, given the following data array:

    [
      {name: 'Bob', checked: true},
      {name: 'Tim', checked: false},
      ...
    ]

The following code would render the list (note the `name` and `checked`
properties are bound from the `model` object provided to the template
scope):

    <core-list data="{{data}}" height="80">
      <template>
        <div class="{{ {selected: selected} | tokenList }}">
          List row: {{index}}, User data from model: {{model.name}}
          <input type="checkbox" checked="{{model.checked}}">
        </div>
      </template>
    </core-list>

By default, the list supports selection via tapping. Styling the selection 
should be done via binding to the `selected` property of each model.

@group Polymer Core Elements
@element core-list
-->
<link rel="import" href="../polymer/polymer.html">
<link rel="import" href="../core-selection/core-selection.html">

<polymer-element name="core-list" on-tap="{{tapHandler}}" tabindex="-1">
<template>
  <core-selection id="selection" multi="{{multi}}" on-core-select="{{selectedHandler}}"></core-selection>
  <link rel="stylesheet" href="core-list.css">
  <div id="viewport" class="core-list-viewport" style="height: {{_viewportHeight}}px">
    <div id="page" class="core-list-page" style="top: {{_pageTop}}; bottom: {{_pageBottom}}"><content></content></div>
  </div>
</template>
<script>
(function() {

  Polymer('core-list', {
    
    publish: {
      /**
       * Fired when an item element is tapped.
       * 
       * @event core-activate
       * @param {Object} detail
       *   @param {Object} detail.item the item element
       */

      /**
       * 
       * An array of source data for the list to display.
       *
       * @attribute data
       * @type array
       * @default null
       */
      data: null,

      groups: null,

      /**
       * 
       * An optional element on which to listen for scroll events.
       *
       * @attribute scrollTarget
       * @type Element
       * @default core-list
       */
      scrollTarget: null,

      /**
       * 
       * The height of a list item. `core-list` currently supports only fixed-height
       * list items. This height must be specified via the height property.
       *
       * @attribute height
       * @type number
       * @default 80
       */
      height: 80,

      /**
       * 
       * The number of extra items rendered above the minimum set required to
       * fill the list's height.
       *
       * @attribute extraItems
       * @type number
       * @default 30
       */
      extraItems: 10,

      /**
       * 
       * When true, tapping a row will select the item, placing its data model
       * in the set of selected items retrievable via the `selection` property.
       *
       * Note that tapping focusable elements within the list item will not
       * result in selection, since they are presumed to have their own action.
       *
       * @attribute selectionEnabled
       * @type {boolean}
       * @default true
       */
      selectionEnabled: true,

      /**
       * 
       * Set to true to support multiple selection.  Note, existing selection
       * state is maintained only when changing `multi` from `false` to `true`;
       * it is cleared when changing from `true` to `false`.
       *
       * @attribute multi
       * @type boolean
       * @default false
       */
      multi: false,

      /**
       * 
       * Data record (or array of records, if `multi: true`) corresponding to
       * the currently selected set of items.
       *
       * @attribute selection
       * @type {any}
       * @default null
       */
       selection: null
    },

    // Local cache of scrollTop
    _scrollTop: 0,
    
    observe: {
      'data groups template scrollTarget': 'initialize',
      'multi selectionEnabled': '_resetSelection'
    },

    ready: function() {
      this._boundScrollHandler = this.scrollHandler.bind(this);
      this._oldMulti = this.multi;
      this._oldSelectionEnabled = this.selectionEnabled;
      this._virtualStart = 0;
      this._virtualCount = 0;
      this._physicalOffset = 0;
      this._pagePosBasis = 'top';
      this._pageTop = null;
      this._pageBottom = null;
      this._physicalSize = 0;
      this._physicalSizes = [];

      this._nestedGroups = false;
      this._groupStart = 0;
      this._groupStartIndex = 0;
    },

    attached: function() {
      this.template = this.querySelector('template');
      if (!this.template.bindingDelegate) {
        this.template.bindingDelegate = this.element.syntax;
      }
    },

    _resetSelection: function() {
      if (((this._oldMulti != this.multi) && !this.multi) || 
          ((this._oldSelectionEnabled != this.selectionEnabled) && 
            !this.selectionEnabled)) {
        this._clearSelection();
        this.refresh(true);
      } else {
        this.selection = this.$.selection.getSelection();
      }
      this._oldMulti = this.multi;
      this._oldSelectionEnabled = this.selectionEnabled;
    },

    _updateSelection: function(splices) {
      for (var i=0; i<splices.length; i++) {
        var s = splices[i];
        for (var j=0; j<s.removed.length; j++) {
          var d = s.removed[j];
          this.$.selection.setItemSelected(d, false);
        }
      }
    },

    // TODO(sorvell): it'd be nice to dispense with 'data' and just use 
    // template repeat's model. However, we need tighter integration
    // with TemplateBinding for this.
    initialize: function() {
      if (!this.template) {
        return;
      }

      // TODO(kschaaf): This is currently the only way to know that the array
      // was mutated as opposed to newly assigned; to be updated with better API
      var splices;
      if (arguments.length == 1) {
        splices = arguments[0];
        this._updateSelection(splices, false);
      } else {
        this._clearSelection();
      }

      var target = this.scrollTarget || this;
      if (this._target !== target) {
        if (this._target) {
          this._target.removeEventListener('scroll', this._boundScrollHandler, false);
        }
        this._target = target;
        this._target.addEventListener('scroll', this._boundScrollHandler, false);
      }

      this.initializeData(splices, false);
    },

    updateGroupObservers: function(splices) {
      // If we're going from grouped to non-grouped, remove all observers
      if (!this._nestedGroups && this._groupObservers && this._groupObservers.length) {
        splices = [{
          index: 0,
          addedCount: 0,
          removed: this._groupObservers
        }];
      }
      // Otherwise, create observers for all groups, unless this is a group splice
      if (this._nestedGroups) {
        splices = splices || [{
          index: 0,
          addedCount: this.data.length,
          removed: []
        }];
      }
      if (splices) {
        var observers = this._groupObservers || [];
        // Apply the splices to the observer array
        for (var i=0; i<splices.length; i++) {
          var s = splices[i], j;
          var args = [s.index, s.removed.length];
          if (s.removed.length) {
            for (j=s.index; j<s.removed.length; j++) {
              observers[j].close();
            }
          }
          if (s.addedCount) {
            for (j=s.index; j<s.addedCount; j++) {
              var o = new ArrayObserver(this.data[j]);
              args.push(o);
              o.open(this.getGroupDataHandler(j));
            }
          }
          observers.splice.apply(observers, args);
        }
        this._groupObservers = observers;
      }
    },

    getGroupDataHandler: function(group) {
      return function(splices) {
        this.groupDataChanged(group, splices);
      }.bind(this);
    },

    groupDataChanged: function(group, splices) {
      console.log('groupDataChanged', group, splices);
      this._updateSelection(splices);
      this.initializeData(null, true);
    },

    initializeData: function(splices, groupUpdate) {
      // Count virtual data size, depending on whether grouping is enabled
      if (!this.data) {        
        this._virtualCount = 0;
        this._nestedGroups = false;
      } else if (this.groups) {
        this._nestedGroups = Array.isArray(this.data[0]);
        if (this._nestedGroups) {
          if (this.groups.length != this.data.length) {
            throw 'When using nested grouped data, data.length and groups.length must agree!';
          }
          this._virtualCount = 0;
          for (var i=0; i<this.groups.length; i++) {
            this._virtualCount += this.data[i] && this.data[i].length;
          }
        } else {
          this._virtualCount = this.data.length;
        }
      } else {
        this._nestedGroups = false;
        this._virtualCount = this.data.length;
      }

      // Update grouped array observers used when group data is nested
      if (!groupUpdate) {
        this.updateGroupObservers(splices);
      }
      
      // Add physical items up to a max based on data length, viewport size, and extra item overhang
      var currentCount = this._physicalCount || 0;
      this._visibleCount = Math.ceil(this._target.offsetHeight / this.height);
      this._physicalCount = Math.min(this._visibleCount + this.extraItems, this._virtualCount);
      this._physicalCount = Math.max(currentCount, this._physicalCount);
      this._physicalData = this._physicalData || new Array(this._physicalCount);
      var needItemInit = false;
      while (currentCount < this._physicalCount) {
        this._physicalData[currentCount++] = {};
        needItemInit = true;
      }
      this.template.model = this._physicalData;
      this.template.setAttribute('repeat', '');
      if (needItemInit) {
        this.resetMetrics();
        this.onMutation(this, this.initializeItems);
      } else {
        this.refresh(true);
      }
    },

    initializeItems: function() {
      var currentCount = this._physicalItems && this._physicalItems.length || 0;
      this._physicalItems = this._physicalItems || new Array(this._physicalCount);
      for (var i = 0, item = this.template.nextElementSibling;
           item && i < this._physicalCount;
           ++i, item = item.nextElementSibling) {
        this._physicalItems[i] = item;
        item._transformValue = 0;
      }
      // Flag to refresh, since we'll need one additional refresh after data is
      // populated to determine correct metrics
      this._itemInitRefresh = true;
      this.refresh(true);
    },

    updateItem: function(physicalIndex, groupIndex, groupItemIndex, virtualIndex) {
      var physicalDatum = this._physicalData[physicalIndex];
      var virtualDatum;
      if (groupIndex == null) {
        virtualDatum = this.data && this.data[virtualIndex];
        physicalDatum.groupIndex = null;
        physicalDatum.isDivider = null;
        physicalDatum.groupModel = null;
      } else {
        virtualDatum = this.data && this._nestedGroups ? this.data[groupIndex][groupItemIndex] : this.data[virtualIndex];
        physicalDatum.groupIndex = groupIndex;
        physicalDatum.isDivider = (groupItemIndex === 0);
        var groupModel = this.groups[groupIndex];
        physicalDatum.groupModel = this._nestedGroups ? groupModel : groupModel.data;
      }
      physicalDatum.model = virtualDatum;
      physicalDatum.index = virtualIndex;
      physicalDatum.groupIndex = this.groups ? groupIndex : null;
      physicalDatum.groupItemIndex = this.groups ? groupItemIndex : null;
      physicalDatum.physicalIndex = physicalIndex;
      physicalDatum.selected = this.selectionEnabled && virtualDatum ? 
          this._selectedData.get(virtualDatum) : null;
      var physicalItem = this._physicalItems[physicalIndex];
      physicalItem.hidden = !virtualDatum;
      physicalItem.classList.toggle('core-list-hide-divider', !physicalDatum.isDivider);
    },

    scrollHandler: function(e, detail) {
      var lastScrollTop = this._scrollTop;
      this._scrollTop = e.detail ? e.detail.target.scrollTop : e.target.scrollTop;
      this.refresh(false, this._scrollTop - lastScrollTop);
    },

    resetMetrics: function() {
      this._metricsInvalidated = true;
      this._physicalAverage = 0;
      this._physicalAverageCount = 0;
    },

    updateMetrics: function(force) {
      if (force || this._metricsInvalidated) {
        var totalSize = 0;
        var count = 0;
        for (var i=0; i<this._physicalCount; i++) {
          var item = this._physicalItems[i];
          var size = this._physicalSizes[i] = item.offsetHeight;
          if (!item.hidden) {
            count++;
            totalSize += size;
          }
        }
        this._physicalSize = totalSize;
        
        totalSize = (this._physicalAverage * this._physicalAverageCount) + totalSize;
        this._physicalAverageCount += count;
        this._physicalAverage = totalSize / this._physicalAverageCount;

        this._metricsInvalidated = false;
      }
    },

    getGroupLen: function(group) {
      group = arguments.length ? group : this._groupStart;
      if (this._nestedGroups) {
        return this.data[group].length;
      } else {
        return this.groups[group].length;
      }
    },

    changeIndex: function(inc) {
      this._virtualStart += inc;
      if (this.groups) {
        while (inc > 0) {
          var groupMax = this.getGroupLen() - this._groupStartIndex - 1;
          if (inc > groupMax) {
            inc -= (groupMax + 1);
            this._groupStart++;
            this._groupStartIndex = 0;
          } else {
            this._groupStartIndex += inc;
            inc = 0;
          }
        }
        while (inc < 0) {
          if (-inc > this._groupStartIndex) {
            inc += this._groupStartIndex;
            this._groupStart--;
            this._groupStartIndex = this.getGroupLen();
          } else {
            this._groupStartIndex += inc;
            inc = this.getGroupLen();
          }
        }
      }
    },

    groupForVirtualIndex: function(virtual) {
      if (!this.groups) {
        return {};
      } else {
        var group;
        for (group=0; group<this.groups.length; group++) {
          var groupLen = this.getGroupLen(group);
          if (groupLen > virtual) {
            break;
          } else {
            virtual -= groupLen;
          }
        }
        return {group: group, groupIndex: virtual };
      }
    },

    virtualIndexForGroup: function(group, groupIndex) {
      group--;
      while (group >= 0) {
        groupIndex += this.getGroupLen(group--);
      }
      return groupIndex;
    },

    dataForIndex: function(virtual, group, groupIndex) {
      if (this._nestedGroups) {
        return this.data[group][groupIndex];
      } else {
        return this.data[virtual];
      }
    },

    setPageBias: function(bias) {
      if (this._pagePosBasis != bias) {
        this._pagePosBasis = bias;
        this._physicalOffset = (this._viewportHeight - this._physicalOffset - this.$.page.offsetHeight);
        return true;
      }
    },

    /**
     * Refresh the list at the current scroll position.
     *
     * @method refresh
     */
    refresh: function(force, delta) {
      if (!this.data) {
        return;
      }

      var i, size, limit, adjustData, adjustViewport, groupLen, deltaHeight;

      this.updateMetrics(force);

      // Random access to point in list
      if (Math.abs(delta) > this._physicalSize || this._scrollToIndex != null) {
        var deltaCount;
        if (this._scrollToIndex != null) {
          // Scrolling to specific index is a special case of random access
          if (this._scrollToIndex > this._virtualCount - (this._target.offsetHeight / this._physicalAverage)) {
            // Index near bottom requires bottom offset and guestimate virtual start
            this.setPageBias('bottom');
            this._target.scrollTop = this._viewportHeight - this._target.offsetHeight;
            this._scrollTop = this._target.scrollTop;
            this._physicalOffset = 0;
            deltaCount = this._virtualCount - Math.round(this._physicalSize / this._physicalAverage) - this._virtualStart;
          } else {
            this.setPageBias('top');
            this._target.scrollTop = this._scrollToIndex * this._physicalAverage;
            this._scrollTop = this._target.scrollTop;
            this._physicalOffset = this._scrollTop;
            deltaCount = this._scrollToIndex - this._virtualStart;
          }
          this._scrollToIndex = null;
        } else if (this._scrollTop < this._physicalAverage * this._physicalCount / 3) {
          // Jumping to top-ish of list
          deltaCount = -this._virtualStart;
          this.setPageBias('top');
          this._physRicalOffset = 0;
        } else if (this._scrollTop > this._viewportHeight - this._physicalAverage * this._physicalCount  / 3) {
          // Jumping to bottom-ish of list
          deltaCount = this._virtualCount - this._physicalCount - this._virtualStart;
          this.setPageBias('bottom');
          this._physicalOffset = 0;
        } else {
          // Jumping somewhere in the middle
          deltaCount = Math.round(delta / this._physicalAverage);
          deltaCount = Math.min(deltaCount, this._virtualCount - this._virtualStart - 1);
          deltaCount = Math.max(deltaCount, -this._virtualStart);
          this.setPageBias('top');
          this._physicalOffset += delta;
        }
        this.changeIndex(deltaCount);
        adjustViewport = true;
        adjustData = true;
        delta = 0; // Avoid flipping logic
        console.log(this._scrollTop, 'random access, new index', this._virtualStart);
        requestAnimationFrame(function() {
          this.updateMetrics(true);
        }.bind(this));
      }

      // Flip items up or down
      if (this._physicalSize > this._target.offsetHeight) {
        if (delta > 0) {
          // Scrolling down; Flip page positioning basis if needed
          if (this.setPageBias('top')) {
            adjustViewport = true;
          }
          // Adjust scroll position
          deltaHeight = this._viewportHeight - this._physicalOffset - this.$.page.offsetHeight;
          if (this._virtualStart < this._virtualCount - this._physicalCount) {
            deltaHeight = Math.min(deltaHeight - 2 * this._target.offsetHeight, 0);
          }
          if (deltaHeight) {
            this._target.scrollTop += deltaHeight;
            this._scrollTop = this._target.scrollTop;
            this._physicalOffset += deltaHeight;
            console.log('adjusting scroll pos by ' + deltaHeight);
            adjustViewport = true;
          }
          // Flip down
          limit = this._scrollTop - this._physicalOffset - (this._physicalSize - this._target.offsetHeight) * 0.25;
          // console.log(this._scrollTop, 'limit:', limit);
          for (i=0; (i<this._physicalCount) && (limit > 0) && (this._virtualStart < this._virtualCount - this._physicalCount); i++) {
            adjustViewport = true;
            adjustData = true;
            size = this._physicalSizes[i];
            this._physicalOffset += size;
            limit -= size;
            console.log(this._scrollTop, 'flip down', this._virtualStart, size, limit);
            this.changeIndex(+1);
          }
        } else if (delta < 0) {
          // Scrolling up; Flip page positioning basis if needed
          if (this.setPageBias('bottom')) {
            adjustViewport = true;
          }
          // Adjust scroll position
          deltaHeight = this._viewportHeight - this._physicalOffset - this.$.page.offsetHeight;
          if (this._virtualStart > this._physicalCount) {
            deltaHeight = Math.min(deltaHeight - 2 * this._target.offsetHeight, 0);
          }
          if (deltaHeight) {
            this._target.scrollTop -= deltaHeight;
            this._scrollTop = this._target.scrollTop;
            this._physicalOffset += deltaHeight;
            console.log('adjusting scroll pos by ' + deltaHeight);
            adjustViewport = true;
          }
          // Flip up
          limit = (this._viewportHeight - this._physicalOffset - this.$.page.offsetHeight) - this._scrollTop + (this._physicalSize - this._target.offsetHeight) * 0.75;
          // console.log(this._scrollTop, 'limit:', limit);
          for (i=this._physicalCount-1; (i >= 0) && (limit > 0) && (this._virtualStart > 0); i--) {
            adjustViewport = true;
            adjustData = true;
            size = this._physicalSizes[i];
            this._physicalOffset += size;
            limit -= size;
            console.log(this._scrollTop, 'flip up at', this._virtualStart, size, limit);
            this.changeIndex(-1);
          }
        }
      }

      // Reset viewport height and adjust offset
      var lastHeight = this._viewportHeight;
      this._viewportHeight = this._physicalAverage * this._virtualCount;
      deltaHeight = this._viewportHeight - lastHeight;
      if (deltaHeight) {
        if (this._pagePosBasis == 'bottom') {
          this._physicalOffset += deltaHeight;
        }
        adjustViewport = true;
      }

      if (adjustData || force) {
        // Re-assign data
        var group = this.groups && this._groupStart;
        var index = this._groupStartIndex;
        for (i = 0; i < this._physicalCount; ++i) {
          this.updateItem(i, group, index, this._virtualStart + i);
          index++;
          if (this.groups && group < this.groups.length - 1) {
            if (index >= this.getGroupLen(group)) {
              index = 0;
              group++;
            }
          }
        }
        this._metricsInvalidated = true;
      }

      if (adjustViewport || force) {
        // Position page (bindings are used for positioning so offset shift & 
        // data shift happen in same frame on polyfill)
        if (this._pagePosBasis == 'top') {
          this._pageTop = this._physicalOffset + 'px';
          this._pageBottom = 'auto';
        } else {
          this._pageTop = 'auto';
          this._pageBottom = this._physicalOffset + 'px';
        }
      }

      if (this._itemInitRefresh) {
        this._itemInitRefresh = false;
        requestAnimationFrame(function() {
          this.resetMetrics();
          this.refresh(true);
        }.bind(this));
      }
    },

    // list selection
    tapHandler: function(e) {
      var n = e.target;
      var p = e.path;
      if (!this.selectionEnabled || (n === this)) {
        return;
      }
      requestAnimationFrame(function() {
        // Gambit: only select the item if the tap wasn't on a focusable child
        // of the list (since anything with its own action should be focusable
        // and not result in result in list selection).  To check this, we
        // asynchronously check that shadowRoot.activeElement is null, which 
        // means the tapped item wasn't focusable. On polyfill where
        // activeElement doesn't follow the data-hinding part of the spec, we
        // can check that document.activeElement is the list itself, which will
        // catch focus in lieu of the tapped item being focusable, as we make
        // the list focusable (tabindex="-1") for this purpose.  Note we also
        // allow the list items themselves to be focusable if desired, so those
        // are excluded as well.
        var active = window.ShadowDOMPolyfill ? 
            wrap(document.activeElement) : this.shadowRoot.activeElement;
        if (active && (active != this) && (active.parentElement != this) && 
            (document.activeElement != document.body)) {
          return;
        }
        // Unfortunately, Safari does not focus certain form controls via mouse,
        // so we also blacklist input, button, & select
        // (https://bugs.webkit.org/show_bug.cgi?id=118043)
        if ((p[0].localName == 'input') || 
            (p[0].localName == 'button') || 
            (p[0].localName == 'select')) {
          return;
        }

        var model = n.templateInstance && n.templateInstance.model;
        if (model) {
          var data = this.dataForIndex(model.index, model.groupIndex, model.groupItemIndex);
          var item = this._physicalItems[model.physicalIndex];
          this.$.selection.select(data);
          this.asyncFire('core-activate', {data: data, item: item});
        }
      }.bind(this));
    },

    selectedHandler: function(e, detail) {
      this.selection = this.$.selection.getSelection();
      var id = this.indexesForData(detail.item);
      // TODO(sorvell): we should be relying on selection to store the
      // selected data but we want to optimize for lookup.
      this._selectedData.set(detail.item, detail.isSelected);
      if (id.physical >= 0 && id.virtual >= 0) {
        var gd = this.groupForVirtualIndex(id.virtual);
        this.updateItem(id.physical, gd.group, gd.groupIndex, id.virtual);
      }
    },

    /**
     * Select the list item at the given index.
     *
     * @method selectItem
     * @param {number} index 
     */
    selectItem: function(index) {
      if (!this.selectionEnabled) {
        return;
      }
      var data = this.data[index];
      if (data) {
        this.$.selection.select(data);
      }
    },

    /**
     * Set the selected state of the list item at the given index.
     *
     * @method setItemSelected
     * @param {number} index 
     * @param {boolean} isSelected 
     */
    setItemSelected: function(index, isSelected) {
      var data = this.data[index];
      if (data) {
        this.$.selection.setItemSelected(data, isSelected);
      }
    },

    indexesForData: function(data) {
      var virtual = -1;
      var groupsLen = 0;
      if (this._nestedGroups) {
        for (var i=0; i<this.groups.length; i++) {
          virtual = this.data[i].indexOf(data);
          if (virtual < 0) {
            groupsLen += this.data[i].length;
          } else {
            virtual += groupsLen;
            break;
          }
        }
      } else {
        virtual = this.data.indexOf(data);
      }
      var physical = this.virtualToPhysicalIndex(virtual);
      return { virtual: virtual, physical: physical };
    },

    virtualToPhysicalIndex: function(index) {
      for (var i=0, l=this._physicalData.length; i<l; i++) {
        if (this._physicalData[i].index === index) {
          return i;
        }
      }
      return -1;
    },

    /**
     * Clears the current selection state of the list.
     *
     * @method clearSelection
     */
    clearSelection: function() {
      this._clearSelection();
      this.refresh(true);
    },

    _clearSelection: function() {
      this._selectedData = new WeakMap();
      this.$.selection.clear();
      this.selection = this.$.selection.getSelection();
    },

    scrollToIndex: function(group, index) {
      if (arguments.length == 2) {
        index = this.virtualIndexForGroup(group, index);
      } else {
        index = group;
      }
      this._scrollToIndex = index;
      this.refresh(true);
      console.log('scroll from ' + this._scrollTop + ' to ' + this._target.scrollTop);
    },

    scrollToGroup: function(group) {
      var index = 0;
      for (var i=0; i<group; i++) {
        index += this.getGroupLen(i);
      }
      this.scrollToIndex(index);
    }

  });

})();
</script>
</polymer-element>
