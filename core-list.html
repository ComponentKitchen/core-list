<!--
Copyright (c) 2014 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
-->

<!--
`core-list` displays a virtual, 'infinite' list. The template inside the 
`core-list` element represents the dom to create for each list item. The
`data` property specifies an array of list item data. The `height` property
represents the fixed height of a list item (variable height list items are
not supported).

`core-list` manages a viewport of data based on the current scroll position.
For performance reasons, not every item in the list is rendered at once.

List item templates should bind to template models of the following structure

    {
      index: 0,         // list index for this item
      selected: false,  // selection state for this item
      model: {          // user data corresponding to data[index]
        /* user data  */
      }
    }

For example, given the following data array:

    [
      {name: 'Bob', checked: true},
      {name: 'Tim', checked: false},
      ...
    ]

The following code would render the list (note the `name` and `checked`
properties are bound from the `model` object provided to the template
scope):

    <core-list data="{{data}}" height="80">
      <template>
        <div class="{{ {selected: selected} | tokenList }}">
          List row: {{index}}, User data from model: {{model.name}}
          <input type="checkbox" checked="{{model.checked}}">
        </div>
      </template>
    </core-list>

By default, the list supports selection via tapping. Styling the selection 
should be done via binding to the `selected` property of each model.

@group Polymer Core Elements
@element core-list
-->
<link rel="import" href="../polymer/polymer.html">
<link rel="import" href="../core-selection/core-selection.html">

<polymer-element name="core-list" on-tap="{{tapHandler}}" tabindex="-1">
<template>
  <core-selection id="selection" multi="{{multi}}" on-core-select="{{selectedHandler}}"></core-selection>
  <link rel="stylesheet" href="core-list.css">
  <div id="viewport" class="core-list-viewport"><content></content></div>
</template>
<script>
(function() {

  Polymer('core-list', {
    
    publish: {
      /**
       * Fired when an item element is tapped.
       * 
       * @event core-activate
       * @param {Object} detail
       *   @param {Object} detail.item the item element
       */

      /**
       * 
       * An array of source data for the list to display.
       *
       * @attribute data
       * @type array
       * @default null
       */
      data: null,

      groups: null,

      /**
       * 
       * An optional element on which to listen for scroll events.
       *
       * @attribute scrollTarget
       * @type Element
       * @default core-list
       */
      scrollTarget: null,

      /**
       * 
       * The height of a list item. `core-list` currently supports only fixed-height
       * list items. This height must be specified via the height property.
       *
       * @attribute height
       * @type number
       * @default 80
       */
      sizingHeight: 250,
      runwayFactor: 4,

      /**
       * 
       * When true, tapping a row will select the item, placing its data model
       * in the set of selected items retrievable via the `selection` property.
       *
       * Note that tapping focusable elements within the list item will not
       * result in selection, since they are presumed to have their own action.
       *
       * @attribute selectionEnabled
       * @type {boolean}
       * @default true
       */
      selectionEnabled: true,

      /**
       * 
       * Set to true to support multiple selection.  Note, existing selection
       * state is maintained only when changing `multi` from `false` to `true`;
       * it is cleared when changing from `true` to `false`.
       *
       * @attribute multi
       * @type boolean
       * @default false
       */
      multi: false,

      /**
       * 
       * Data record (or array of records, if `multi: true`) corresponding to
       * the currently selected set of items.
       *
       * @attribute selection
       * @type {any}
       * @default null
       */
       selection: null
    },

    // Local cache of scrollTop
    _scrollTop: 0,
    
    observe: {
      'data groups template scrollTarget': 'initialize',
      'multi selectionEnabled': '_resetSelection'
    },

    ready: function() {
      this._boundScrollHandler = this.scrollHandler.bind(this);
      this._oldMulti = this.multi;
      this._oldSelectionEnabled = this.selectionEnabled;
      this._virtualStart = 0;
      this._virtualCount = 0;
      this._physicalOffset = 0;
      this._pagePosBasis = 'top';
      this._physicalSize = 0;
      this._physicalSizes = [];

      this._nestedGroups = false;
      this._groupStart = 0;
      this._groupStartIndex = 0;

      // Only use -webkit-overflow-touch from iOS8+, where scroll events are fired
      var ios = navigator.userAgent.match(/iP(?:hone|ad;(?: U;)? CPU) OS (\d+)/);
      if (ios && ios[1] >= 8) {
        this.style.webkitOverflowScrolling = 'touch';
      }

      // Select translate method
      if (document.documentElement.style.transform !== undefined) {
        this._setTranslate = function(element, value) {
          element.style.transform = 'translateY(' + value + 'px)';
          element._translate = value;
        };
      } else {
        this._setTranslate = function(element, value) {
          element.style.webkitTransform = 'translateY(' + value + 'px)';
          element._translate = value;
        };
      }
    },

    attached: function() {
      this.template = this.querySelector('template');
      if (!this.template.bindingDelegate) {
        this.template.bindingDelegate = this.element.syntax;
      }
    },

    _resetSelection: function() {
      if (((this._oldMulti != this.multi) && !this.multi) || 
          ((this._oldSelectionEnabled != this.selectionEnabled) && 
            !this.selectionEnabled)) {
        this._clearSelection();
        this.refresh(true);
      } else {
        this.selection = this.$.selection.getSelection();
      }
      this._oldMulti = this.multi;
      this._oldSelectionEnabled = this.selectionEnabled;
    },

    _updateSelection: function(splices) {
      for (var i=0; i<splices.length; i++) {
        var s = splices[i];
        for (var j=0; j<s.removed.length; j++) {
          var d = s.removed[j];
          this.$.selection.setItemSelected(d, false);
        }
      }
    },

    // TODO(sorvell): it'd be nice to dispense with 'data' and just use 
    // template repeat's model. However, we need tighter integration
    // with TemplateBinding for this.
    initialize: function() {
      if (!this.template) {
        return;
      }

      // TODO(kschaaf): This is currently the only way to know that the array
      // was mutated as opposed to newly assigned; to be updated with better API
      var splices;
      if (arguments.length == 1) {
        splices = arguments[0];
        this._updateSelection(splices, false);
      } else {
        this._clearSelection();
      }

      var target = this.scrollTarget || this;
      if (this._target !== target) {
        if (this._target) {
          this._target.removeEventListener('scroll', this._boundScrollHandler, false);
        }
        this._target = target;
        this._target.addEventListener('scroll', this._boundScrollHandler, false);
        if ((target != this) && target.setScrollTop && target.getScrollTop) {
          this.setScrollTop = function(val) {
            target.setScrollTop(val);
            return target.getScrollTop();
          };
        } else {
          this.setScrollTop = function(val) {
            target.scrollTop = val;
            return target.scrollTop;
          };
        }
      }

      this.initializeData(splices, false);
    },

    updateGroupObservers: function(splices) {
      // If we're going from grouped to non-grouped, remove all observers
      if (!this._nestedGroups && this._groupObservers && this._groupObservers.length) {
        splices = [{
          index: 0,
          addedCount: 0,
          removed: this._groupObservers
        }];
      }
      // Otherwise, create observers for all groups, unless this is a group splice
      if (this._nestedGroups) {
        splices = splices || [{
          index: 0,
          addedCount: this.data.length,
          removed: []
        }];
      }
      if (splices) {
        var observers = this._groupObservers || [];
        // Apply the splices to the observer array
        for (var i=0; i<splices.length; i++) {
          var s = splices[i], j;
          var args = [s.index, s.removed.length];
          if (s.removed.length) {
            for (j=s.index; j<s.removed.length; j++) {
              observers[j].close();
            }
          }
          if (s.addedCount) {
            for (j=s.index; j<s.addedCount; j++) {
              var o = new ArrayObserver(this.data[j]);
              args.push(o);
              o.open(this.getGroupDataHandler(j));
            }
          }
          observers.splice.apply(observers, args);
        }
        this._groupObservers = observers;
      }
    },

    getGroupDataHandler: function(group) {
      return function(splices) {
        this.groupDataChanged(group, splices);
      }.bind(this);
    },

    groupDataChanged: function(group, splices) {
      this._updateSelection(splices);
      this.initializeData(null, true);
    },

    initializeData: function(splices, groupUpdate) {
      // Count virtual data size, depending on whether grouping is enabled
      if (!this.data) {        
        this._virtualCount = 0;
        this._nestedGroups = false;
      } else if (this.groups) {
        this._nestedGroups = Array.isArray(this.data[0]);
        if (this._nestedGroups) {
          if (this.groups.length != this.data.length) {
            throw 'When using nested grouped data, data.length and groups.length must agree!';
          }
          this._virtualCount = 0;
          for (var i=0; i<this.groups.length; i++) {
            this._virtualCount += this.data[i] && this.data[i].length;
          }
        } else {
          this._virtualCount = this.data.length;
        }
      } else {
        this._nestedGroups = false;
        this._virtualCount = this.data.length;
      }

      // Update grouped array observers used when group data is nested
      if (!groupUpdate) {
        this.updateGroupObservers(splices);
      }
      
      // Add physical items up to a max based on data length, viewport size, and extra item overhang
      var currentCount = this._physicalCount || 0;
      this._physicalCount = Math.ceil(Math.min(this._target.offsetHeight / this.sizingHeight * this.runwayFactor), this._virtualCount);
      this._physicalCount = Math.max(currentCount, this._physicalCount);
      this._physicalData = this._physicalData || new Array(this._physicalCount);
      var needItemInit = false;
      while (currentCount < this._physicalCount) {
        this._physicalData[currentCount++] = {};
        needItemInit = true;
      }
      this.template.model = this._physicalData;
      this.template.setAttribute('repeat', '');
      if (needItemInit) {
        this.resetMetrics();
        this.onMutation(this, this.initializeItems);
      } else {
        this.refresh(true);
      }
    },

    initializeItems: function() {
      var currentCount = this._physicalItems && this._physicalItems.length || 0;
      this._physicalItems = this._physicalItems || new Array(this._physicalCount);
      for (var i = 0, item = this.template.nextElementSibling;
           item && i < this._physicalCount;
           ++i, item = item.nextElementSibling) {
        this._physicalItems[i] = item;
        item._transformValue = 0;
      }
      // Flag to refresh, since we'll need one additional refresh after data is
      // populated to determine correct metrics
      this._itemInitRefresh = true;
      this.refresh(true);
    },

    updateItemData: function(physicalItem, physicalIndex, groupIndex, groupItemIndex, virtualIndex) {
      var physicalDatum = this._physicalData[physicalIndex];
      var virtualDatum;
      if (groupIndex == null) {
        virtualDatum = this.data && this.data[virtualIndex];
        physicalDatum.groupIndex = null;
        physicalDatum.isDivider = null;
        physicalDatum.groupModel = null;
      } else {
        virtualDatum = this.data && this._nestedGroups ?
          this.data[groupIndex][groupItemIndex] : this.data[virtualIndex];
        physicalDatum.groupIndex = groupIndex;
        physicalDatum.isDivider = (groupItemIndex === 0);
        var groupModel = this.groups[groupIndex];
        physicalDatum.groupModel = this._nestedGroups ? groupModel : groupModel.data;
      }
      if (physicalDatum.model != virtualDatum) {
        physicalDatum.model = virtualDatum;
        physicalItem._dataInvalidated = true;
      } else {
        physicalItem._dataInvalidated = false;
      }
      physicalDatum.index = virtualIndex;
      physicalDatum.groupIndex = this.groups ? groupIndex : null;
      physicalDatum.groupItemIndex = this.groups ? groupItemIndex : null;
      physicalDatum.physicalIndex = physicalIndex;
      physicalDatum.selected = this.selectionEnabled && virtualDatum ? 
          this._selectedData.get(virtualDatum) : null;
      physicalItem.hidden = !virtualDatum;
      physicalItem.classList.toggle('core-list-hide-divider', !physicalDatum.isDivider);
    },

    scrollHandler: function(e) {
      // console.log('delta', lastScrollTop, this._scrollTop, delta);
      if (this.refreshAsync) {
        this.cancelAsync(this.refreshAsync);
      }
      this.refreshAsync = this.async(function(target) {
        var lastScrollTop = this._scrollTop;
        var scrollTop = this._scrollTop = target.scrollTop;
        var delta = scrollTop - lastScrollTop;
        this._dir = delta < 0 ? -1 : delta > 0 ? 1 : 0;
        console.log(scrollTop, 'scroll refresh', delta);
        this.refresh(false, delta);
        this.refreshAsync = null;
      }, e.detail && e.detail.target || e.target);
    },

    resetMetrics: function() {
      this._physicalAverage = 0;
      this._physicalAverageCount = 0;
    },

    updateMetrics: function(force) {
      var totalSize = 0;
      var count = 0;
      for (var i=0; i<this._physicalCount; i++) {
        var item = this._physicalItems[i];
        if (!item.hidden) {
          var size = this._physicalSizes[i] = item.offsetHeight;
          count++;
          totalSize += size;
        }
      }
      this._physicalSize = totalSize;
      this._viewportHeight = this.$.viewport.offsetHeight;

      // Calculate flip bounds
      var overhang = totalSize - this._target.offsetHeight;
      this._flipBound = this._physicalOffset + (this._dir > 0 ? 0.4 : 0.6) * overhang;

      // Calculate average height
      totalSize = (this._physicalAverage * this._physicalAverageCount) + totalSize;
      this._physicalAverageCount += count;
      this._physicalAverage = Math.round(totalSize / this._physicalAverageCount);
    },

    getGroupLen: function(group) {
      group = arguments.length ? group : this._groupStart;
      if (this._nestedGroups) {
        return this.data[group].length;
      } else {
        return this.groups[group].length;
      }
    },

    changeStartIndex: function(inc) {
      this._virtualStart += inc;
      if (this.groups) {
        while (inc > 0) {
          var groupMax = this.getGroupLen() - this._groupStartIndex - 1;
          if (inc > groupMax) {
            inc -= (groupMax + 1);
            this._groupStart++;
            this._groupStartIndex = 0;
          } else {
            this._groupStartIndex += inc;
            inc = 0;
          }
        }
        while (inc < 0) {
          if (-inc > this._groupStartIndex) {
            inc += this._groupStartIndex;
            this._groupStart--;
            this._groupStartIndex = this.getGroupLen();
          } else {
            this._groupStartIndex += inc;
            inc = this.getGroupLen();
          }
        }
      }
    },

    groupForVirtualIndex: function(virtual) {
      if (!this.groups) {
        return {};
      } else {
        var group;
        for (group=0; group<this.groups.length; group++) {
          var groupLen = this.getGroupLen(group);
          if (groupLen > virtual) {
            break;
          } else {
            virtual -= groupLen;
          }
        }
        return {group: group, groupIndex: virtual };
      }
    },

    virtualIndexForGroup: function(group, groupIndex) {
      group--;
      while (group >= 0) {
        groupIndex += this.getGroupLen(group--);
      }
      return groupIndex;
    },

    dataForIndex: function(virtual, group, groupIndex) {
      if (this._nestedGroups) {
        return this.data[group][groupIndex];
      } else {
        return this.data[virtual];
      }
    },

    setPageBias: function(bias) {
      if (this._pagePosBasis != bias) {
        this._pagePosBasis = bias;
        this._physicalOffset = (this._viewportHeight - this._physicalOffset - this._physicalSize);
        return true;
      }
    },

    /**
     * Refresh the list at the current scroll position.
     *
     * @method refresh
     */
    refresh: function(force, scrollDelta, async, randomAccess) {
      var i, virtualIndex, physicalIndex, physicalItem, deltaCount;

      if (!this.data) {
        return;
      }

      // Random access to point in list
      if (Math.abs(scrollDelta) > this._physicalSize) {
        randomAccess = true;
        deltaCount = Math.round(scrollDelta / this._physicalAverage);
        deltaCount = Math.max(deltaCount, -this._virtualStart);
        deltaCount = Math.min(deltaCount, this._virtualCount - this._virtualStart - 1);
        this._physicalOffset += scrollDelta;
        this.changeStartIndex(deltaCount);
        // console.log(this._scrollTop, 'Random access to ' + this._virtualStart, this._physicalOffset);
      }

      // Jump to index in list (special form of random access)
      if (this._scrollToIndex != null) {
        randomAccess = true;
        deltaCount = this._scrollToIndex - this._virtualStart;
        scrollDelta = deltaCount * this._physicalAverage;
        this._scrollTop = this.setScrollTop(this._scrollTop + scrollDelta);
        this._physicalOffset = this._scrollTop;
        this.changeStartIndex(deltaCount);
        this._scrollToIndex = null;
      }

      // Measure
      this.updateMetrics();

      // Do we need to flip items?
      if (!randomAccess  && !this._upPending && !async &&
          ((this._dir > 0 && this._scrollTop > this._flipBound) ||
           (this._dir < 0 && this._scrollTop < this._flipBound))) {
        var flipSize = Math.abs(this._scrollTop - this._flipBound);
        for (i=0; (i<this._physicalCount) && (flipSize > 0) &&
            ((this._dir < 0 && this._virtualStart > 0) || 
             (this._dir > 0 && this._virtualStart < this._virtualCount-this._physicalCount-1)); i++) {
          var idx = this._dir > 0 ? this._virtualStart : this._virtualStart + this._physicalCount -1;
          var size = this._physicalSizes[idx % this._physicalCount];
          flipSize -= size;
          this.changeStartIndex(this._dir);
          if (this._dir > 0) {
            this._physicalOffset += size;
            // console.log(this._scrollTop, 'flip down', size, this._physicalOffset);
          } else {
            this._upPending = true;  
          }
        }
      }

      // Assign data to items and adjust offset
      var groupIndex = this.groups && this._groupStart;
      var groupItemIndex = this._groupStartIndex;
      for (i = 0; i < this._physicalCount; ++i) {
        virtualIndex = this._virtualStart + i;
        physicalIndex = virtualIndex % this._physicalCount;
        physicalItem = this._physicalItems[physicalIndex];
        // When going up, remove offset after measuring size for
        // new data for item being moved from bottom to top
        if (physicalItem._dataInvalidated && this._dir < 0 && !randomAccess) {
          this._physicalOffset -= this._physicalSizes[physicalIndex];
          this._upPending = false;
          console.log(this._scrollTop, 'flip up', -this._physicalSizes[physicalIndex], this._physicalOffset);
        }
        // Update physical item with new user data and list metadata
        this.updateItemData(physicalItem, physicalIndex, groupIndex, groupItemIndex, virtualIndex);
        // Hide invalidated items until next frame when we have a chance to
        // measure and position them
        physicalItem.style.opacity = physicalItem._dataInvalidated ? 0 : 1;
        // Increment
        groupItemIndex++;
        if (this.groups && groupIndex < this.groups.length - 1) {
          if (groupItemIndex >= this.getGroupLen(groupIndex)) {
            groupItemIndex = 0;
            groupIndex++;
          }
        }
      }

      // Reset viewport height
      if (async) {
        this.$.viewport.style.height = (this._viewportHeight = 
          this._physicalOffset + this._physicalSize + 
          Math.max(this._virtualCount - this._virtualStart - this._physicalCount - 1, 0) * 
            this._physicalAverage) + 'px';
      }

      // Adjust scroll position to home into top-dead-zero
      var deltaHeight;
      if (this._dir < 0) {
        deltaHeight = this._virtualStart === 0 ? this._physicalOffset :
          Math.min(this._scrollTop + this._physicalOffset, 0);
        if (deltaHeight) {
          this._scrollTop = this.setScrollTop(this._scrollTop - deltaHeight);
          this._physicalOffset -= deltaHeight;
          // console.log(this._scrollTop, 'adjusting scroll pos', deltaHeight);
        }
      }

      // Position items
      var offset = this._physicalOffset;
      for (i = 0; i < this._physicalCount; ++i) {
        virtualIndex = this._virtualStart + i;
        physicalIndex = virtualIndex % this._physicalCount;
        physicalItem = this._physicalItems[physicalIndex];
        this._setTranslate(physicalItem, offset);
        if (!physicalItem._dataInvalidated) {
          offset += this._physicalSizes[physicalIndex];
        }
      }

      Platform.performMicrotaskCheckpoint();

      // Schedule another refresh to measure & position items
      if (!async) {
        requestAnimationFrame(function() {
          // console.log('async refresh');
          this.refresh(false, 0, true, randomAccess);
        }.bind(this));
      }
    },

    // list selection
    tapHandler: function(e) {
      var n = e.target;
      var p = e.path;
      if (!this.selectionEnabled || (n === this)) {
        return;
      }
      requestAnimationFrame(function() {
        // Gambit: only select the item if the tap wasn't on a focusable child
        // of the list (since anything with its own action should be focusable
        // and not result in result in list selection).  To check this, we
        // asynchronously check that shadowRoot.activeElement is null, which 
        // means the tapped item wasn't focusable. On polyfill where
        // activeElement doesn't follow the data-hinding part of the spec, we
        // can check that document.activeElement is the list itself, which will
        // catch focus in lieu of the tapped item being focusable, as we make
        // the list focusable (tabindex="-1") for this purpose.  Note we also
        // allow the list items themselves to be focusable if desired, so those
        // are excluded as well.
        var active = window.ShadowDOMPolyfill ? 
            wrap(document.activeElement) : this.shadowRoot.activeElement;
        if (active && (active != this) && (active.parentElement != this) && 
            (document.activeElement != document.body)) {
          return;
        }
        // Unfortunately, Safari does not focus certain form controls via mouse,
        // so we also blacklist input, button, & select
        // (https://bugs.webkit.org/show_bug.cgi?id=118043)
        if ((p[0].localName == 'input') || 
            (p[0].localName == 'button') || 
            (p[0].localName == 'select')) {
          return;
        }

        var model = n.templateInstance && n.templateInstance.model;
        if (model) {
          var data = this.dataForIndex(model.index, model.groupIndex, model.groupItemIndex);
          var item = this._physicalItems[model.physicalIndex];
          this.$.selection.select(data);
          this.asyncFire('core-activate', {data: data, item: item});
        }
      }.bind(this));
    },

    selectedHandler: function(e, detail) {
      this.selection = this.$.selection.getSelection();
      var id = this.indexesForData(detail.item);
      // TODO(sorvell): we should be relying on selection to store the
      // selected data but we want to optimize for lookup.
      this._selectedData.set(detail.item, detail.isSelected);
      if (id.physical >= 0 && id.virtual >= 0) {
        this.refresh(true);
      }
    },

    /**
     * Select the list item at the given index.
     *
     * @method selectItem
     * @param {number} index 
     */
    selectItem: function(index) {
      if (!this.selectionEnabled) {
        return;
      }
      var data = this.data[index];
      if (data) {
        this.$.selection.select(data);
      }
    },

    /**
     * Set the selected state of the list item at the given index.
     *
     * @method setItemSelected
     * @param {number} index 
     * @param {boolean} isSelected 
     */
    setItemSelected: function(index, isSelected) {
      var data = this.data[index];
      if (data) {
        this.$.selection.setItemSelected(data, isSelected);
      }
    },

    indexesForData: function(data) {
      var virtual = -1;
      var groupsLen = 0;
      if (this._nestedGroups) {
        for (var i=0; i<this.groups.length; i++) {
          virtual = this.data[i].indexOf(data);
          if (virtual < 0) {
            groupsLen += this.data[i].length;
          } else {
            virtual += groupsLen;
            break;
          }
        }
      } else {
        virtual = this.data.indexOf(data);
      }
      var physical = this.virtualToPhysicalIndex(virtual);
      return { virtual: virtual, physical: physical };
    },

    virtualToPhysicalIndex: function(index) {
      for (var i=0, l=this._physicalData.length; i<l; i++) {
        if (this._physicalData[i].index === index) {
          return i;
        }
      }
      return -1;
    },

    /**
     * Clears the current selection state of the list.
     *
     * @method clearSelection
     */
    clearSelection: function() {
      this._clearSelection();
      this.refresh(true);
    },

    _clearSelection: function() {
      this._selectedData = new WeakMap();
      this.$.selection.clear();
      this.selection = this.$.selection.getSelection();
    },

    scrollToIndex: function(group, index) {
      if (arguments.length == 2) {
        index = this.virtualIndexForGroup(group, index);
      } else {
        index = group;
      }
      index = Math.min(index, this._virtualCount-1);
      index = Math.max(index, 0);
      this._scrollToIndex = index;
      this.refresh(true);
      // console.log('scroll from ' + this._scrollTop + ' to ' + this._target.scrollTop);
    },

    scrollToGroup: function(group) {
      var index = 0;
      for (var i=0; i<group; i++) {
        index += this.getGroupLen(i);
      }
      this.scrollToIndex(index);
    }

  });

})();
</script>
</polymer-element>
