<!--
Copyright (c) 2014 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
-->

<!--
`core-list` displays a virtual, 'infinite' list. The template inside the 
`core-list` element represents the dom to create for each list item. The
`data` property specifies an array of list item data. The `height` property
represents the fixed height of a list item (variable height list items are
not supported).

`core-list` manages a viewport of data based on the current scroll position.
For performance reasons, not every item in the list is rendered at once.

List item templates should bind to template models of the following structure

    {
      index: 0,         // list index for this item
      selected: false,  // selection state for this item
      model: {          // user data corresponding to data[index]
        /* user data  */
      }
    }

For example, given the following data array:

    [
      {name: 'Bob', checked: true},
      {name: 'Tim', checked: false},
      ...
    ]

The following code would render the list (note the `name` and `checked`
properties are bound from the `model` object provided to the template
scope):

    <core-list data="{{data}}" height="80">
      <template>
        <div class="{{ {selected: selected} | tokenList }}">
          List row: {{index}}, User data from model: {{model.name}}
          <input type="checkbox" checked="{{model.checked}}">
        </div>
      </template>
    </core-list>

By default, the list supports selection via tapping. Styling the selection 
should be done via binding to the `selected` property of each model.

@group Polymer Core Elements
@element core-list
-->
<link rel="import" href="../polymer/polymer.html">
<link rel="import" href="../core-selection/core-selection.html">

<polymer-element name="core-list" on-tap="{{tapHandler}}" tabindex="-1">
<template>
  <core-selection id="selection" multi="{{multi}}" on-core-select="{{selectedHandler}}"></core-selection>
  <link rel="stylesheet" href="core-list.css">
  <div id="viewport" class="core-list-viewport" style="height: {{_viewportHeight}}px">
    <div id="page" class="core-list-page" style="top: {{_pageTop}}; bottom: {{_pageBottom}}"><content></content></div>
  </div>
</template>
<script>
(function() {

  Polymer('core-list', {
    
    publish: {
      /**
       * Fired when an item element is tapped.
       * 
       * @event core-activate
       * @param {Object} detail
       *   @param {Object} detail.item the item element
       */

      /**
       * 
       * An array of source data for the list to display.
       *
       * @attribute data
       * @type array
       * @default null
       */
      data: null,

      groups: null,

      /**
       * 
       * An optional element on which to listen for scroll events.
       *
       * @attribute scrollTarget
       * @type Element
       * @default core-list
       */
      scrollTarget: null,

      /**
       * 
       * The height of a list item. `core-list` currently supports only fixed-height
       * list items. This height must be specified via the height property.
       *
       * @attribute height
       * @type number
       * @default 80
       */
      height: 80,

      /**
       * 
       * The number of extra items rendered above the minimum set required to
       * fill the list's height.
       *
       * @attribute extraItems
       * @type number
       * @default 30
       */
      extraItems: 10,

      /**
       * 
       * When true, tapping a row will select the item, placing its data model
       * in the set of selected items retrievable via the `selection` property.
       *
       * Note that tapping focusable elements within the list item will not
       * result in selection, since they are presumed to have their own action.
       *
       * @attribute selectionEnabled
       * @type {boolean}
       * @default true
       */
      selectionEnabled: true,

      /**
       * 
       * Set to true to support multiple selection.  Note, existing selection
       * state is maintained only when changing `multi` from `false` to `true`;
       * it is cleared when changing from `true` to `false`.
       *
       * @attribute multi
       * @type boolean
       * @default false
       */
      multi: false,

      /**
       * 
       * Data record (or array of records, if `multi: true`) corresponding to
       * the currently selected set of items.
       *
       * @attribute selection
       * @type {any}
       * @default null
       */
       selection: null
    },

    // Local cache of scrollTop
    _scrollTop: 0,
    
    observe: {
      'data groups template scrollTarget': 'initialize',
      'multi selectionEnabled': '_resetSelection'
    },

    ready: function() {
      this._boundScrollHandler = this.scrollHandler.bind(this);
      this._oldMulti = this.multi;
      this._oldSelectionEnabled = this.selectionEnabled;
      this._virtualStart = 0;
      this._virtualCount = 0;
      this._physicalOffset = 0;
      this._pagePosBasis = 'top';
      this._pageTop = null;
      this._pageBottom = null;
      this._physicalSize = 0;
      this._physicalSizes = [];

      this._flatGroups = false;
      this._groupStart = 0;
      this._groupStartIndex = 0;
    },

    attached: function() {
      this.template = this.querySelector('template');
      if (!this.template.bindingDelegate) {
        this.template.bindingDelegate = this.element.syntax;
      }
    },

    _resetSelection: function() {
      if (((this._oldMulti != this.multi) && !this.multi) || 
          ((this._oldSelectionEnabled != this.selectionEnabled) && 
            !this.selectionEnabled)) {
        this._clearSelection();
        this.refresh(true);
      } else {
        this.selection = this.$.selection.getSelection();
      }
      this._oldMulti = this.multi;
      this._oldSelectionEnabled = this.selectionEnabled;
    },

    // TODO(sorvell): it'd be nice to dispense with 'data' and just use 
    // template repeat's model. However, we need tighter integration
    // with TemplateBinding for this.
    initialize: function() {
      if (!this.template) {
        return;
      }

      // TODO(kschaaf): This is currently the only way to know that the array
      // was mutated as opposed to newly assigned; to be updated with better API
      if (arguments.length == 1) {
        var splices = arguments[0];
        for (var i=0; i<splices.length; i++) {
          var s = splices[i];
          for (var j=0; j<s.removed.length; j++) {
            var d = s.removed[j];
            this.$.selection.setItemSelected(d, false);
          }
        }
      } else {
        this._clearSelection();
      }

      var target = this.scrollTarget || this;
      if (this._target !== target) {
        if (this._target) {
          this._target.removeEventListener('scroll', this._boundScrollHandler, false);
        }
        this._target = target;
        this._target.addEventListener('scroll', this._boundScrollHandler, false);
      }

      this.initializeData();
    },

    initializeData: function() {
      // Count virtual data size, depending on whether grouping is enabled
      if (!this.data) {        
        this._virtualCount = 0;
      } else if (this.groups) {
        // if (this.stickyDivider) {
        //   this.stickyDivider.remove();
        // }
        // this.stickyDivider = list.appendChild(document.importNode(this.template.ref_.content.querySelector('[divider]')));
        // if (this.stickyDivider) {
        //   this.stickyDivider.style.position = 'absolute';
        // }
        this._flatGroups = !Array.isArray(this.data[0]);
        if (this._flatGroups) {
          this._virtualCount = this.data.length;
        } else {
          this._virtualCount = 0;
          for (var i=0; i<this.groups.length; i++) {
            this._virtualCount += this.data[i] && this.data[i].length;
          }
        }
      } else {
        this._virtualCount = this.data.length;
      }
      
      // Add physical items up to a max based on data length, viewport size, and extra item overhang
      var currentCount = this._physicalCount || 0;
      this._visibleCount = Math.ceil(this._target.offsetHeight / this.height);
      this._physicalCount = Math.min(this._visibleCount + this.extraItems, this._virtualCount);
      this._physicalCount = Math.max(currentCount, this._physicalCount);
      this._physicalData = this._physicalData || new Array(this._physicalCount);
      var needItemInit = false;
      while (currentCount < this._physicalCount) {
        this._physicalData[currentCount++] = {};
        needItemInit = true;
      }
      this.template.model = this._physicalData;
      this.template.setAttribute('repeat', '');
      if (needItemInit) {
        this.onMutation(this, this.initializeItems);
      } else {
        this.refresh(true);
      }
    },

    initializeItems: function() {
      var currentCount = this._physicalItems && this._physicalItems.length || 0;
      this._physicalItems = this._physicalItems || new Array(this._physicalCount);
      for (var i = 0, item = this.template.nextElementSibling;
           item && i < this._physicalCount;
           ++i, item = item.nextElementSibling) {
        this._physicalItems[i] = item;
        item._transformValue = 0;
      }
      this.refresh(true);
    },

    updateItem: function(physicalIndex, groupIndex, groupItemIndex, virtualIndex) {
      var physicalDatum = this._physicalData[physicalIndex];
      var virtualDatum;
      if (groupIndex == null) {
        virtualDatum = this.data && this.data[virtualIndex];
        physicalDatum.groupIndex = null;
        physicalDatum.isDivider = null;
        physicalDatum.groupModel = null;
      } else {
        virtualDatum = this.data && this._flatGroups ? this.data[virtualIndex] : this.data[groupIndex][groupItemIndex];
        physicalDatum.groupIndex = groupIndex;
        physicalDatum.isDivider = (groupItemIndex === 0);
        var groupModel = this.groups[groupIndex];
        physicalDatum.groupModel = this._flatGroups ? groupModel.data : groupModel;
      }
      physicalDatum.model = virtualDatum;
      physicalDatum.index = this.groups && !this._flatGroups ? groupItemIndex : virtualIndex;
      physicalDatum.groupIndex = this.groups ? groupIndex : null;
      physicalDatum.groupItemIndex = groupItemIndex;
      physicalDatum.physicalIndex = physicalIndex;
      physicalDatum.selected = this.selectionEnabled && virtualDatum ? 
          this._selectedData.get(virtualDatum) : null;
      var physicalItem = this._physicalItems[physicalIndex];
      physicalItem.hidden = !virtualDatum;
      physicalItem.classList.toggle('core-list-hide-divider', !physicalDatum.isDivider);
    },

    scrollHandler: function(e, detail) {
      var lastScrollTop = this._scrollTop;
      this._scrollTop = e.detail ? e.detail.target.scrollTop : e.target.scrollTop;
      this.refresh(false, this._scrollTop - lastScrollTop);
    },

    updateMetrics: function() {
      var totalSize = 0;
      for (var i=0; i<this._physicalCount; i++) {
        var size = this._physicalSizes[i] = this._physicalItems[i].offsetHeight;
        totalSize += size;
      }
      this._physicalSize = totalSize;
      this._physicalAverage = totalSize / this._physicalCount;
    },

    getGroupLen: function(group) {
      group = arguments.length ? group : this._groupStart;
      if (this._flatGroups) {
        return this.groups[group].length;
      } else {
        return this.data[group].length;
      }
    },

    changeIndex: function(inc) {
      this._virtualStart += inc;
      if (this.groups) {
        while (inc > 0) {
          var groupMax = this.getGroupLen() - this._groupStartIndex;
          if (inc > groupMax) {
            inc -= groupMax;
            this._groupStart++;
            this._groupStartIndex = 0;
          } else {
            this._groupStartIndex += inc;
            inc = 0;
          }
        }
        while (inc < 0) {
          if (-inc > this._groupStartIndex) {
            inc += this._groupStartIndex;
            this._groupStart--;
            this._groupStartIndex = this.getGroupLen();
          } else {
            this._groupStartIndex += inc;
            inc = this.getGroupLen();
          }
        }
      }
    },

    /**
     * Refresh the list at the current scroll position.
     *
     * @method refresh
     */
    refresh: function(force, delta) {

      if (!this.data) {
        return;
      }

      var i, size, limit, adjustNeeded, groupLen, deltaHeight;

      this.updateMetrics(force);

      // Random access to point in list
      if (Math.abs(delta) > this._physicalSize) {
        if (false) {
          console.log('random access required but not implemented');
        } else {
          var deltaCount = delta / this._physicalAverage;
          var count;
          this._virtualStart += deltaCount;
          if (this.groups) {
          }
          this._physicalOffset += delta;
          adjustNeeded = true;
          delta = 0; // Avoid flipping logic
          console.log(this._scrollTop, 'random access, new index', this._virtualStart);
        }
      }

      // Flip items up or down
      if (this._physicalSize > this._target.offsetHeight) {
        if (delta > 0) {
          // Scrolling down; Flip page positioning basis if needed
          if (this._pagePosBasis != 'top') {
            this._pagePosBasis = 'top';
            this._physicalOffset = (this._viewportHeight - this._physicalOffset - this.$.page.offsetHeight);
            adjustNeeded = true;
          }
          // Ensure the scroller lands exactly at the bottom
          if (this._virtualStart == this._virtualCount - this._physicalCount) {
            deltaHeight = this._viewportHeight - this._physicalOffset - this.$.page.offsetHeight;
            this._target.scrollTop += deltaHeight;
            this._physicalOffset += deltaHeight;
            console.log('resetting scroll pos!');
            adjustNeeded = true;
          }
          // Flip down
          limit = this._scrollTop - this._physicalOffset - (this._physicalSize - this._target.offsetHeight) * 0.75;
          console.log(this._scrollTop, 'limit:', limit);
          for (i=0; (i<this._physicalCount) && (limit > 0) && (this._virtualStart < this._virtualCount - this._physicalCount); i++) {
            adjustNeeded = true;
            size = this._physicalSizes[i] || this._physicalAverage;
            this._physicalOffset += size;
            limit -= size;
            console.log(this._scrollTop, 'flip down', this._virtualStart, size, limit);
            this.changeIndex(+1);
          }
        } else if (delta < 0) {
          // Scrolling up; Flip page positioning basis if needed
          if (this._pagePosBasis != 'bottom') {
            this._pagePosBasis = 'bottom';
            this._physicalOffset = (this._viewportHeight - this._physicalOffset - this.$.page.offsetHeight);
            adjustNeeded = true;
          }
          // Ensure the scroller lands back at the top
          if (this._virtualStart === 0) {
            deltaHeight = this._viewportHeight - this._physicalOffset - this.$.page.offsetHeight;
            this._target.scrollTop -= deltaHeight;
            this._physicalOffset += deltaHeight;
            console.log('resetting scroll pos!');
            adjustNeeded = true;
          }
          // Flip up
          limit = (this._viewportHeight - this._physicalOffset - this.$.page.offsetHeight) - this._scrollTop + (this._physicalSize - this._target.offsetHeight) * 0.25;
          console.log(this._scrollTop, 'limit:', limit);
          for (i=this._physicalCount-1; (i >= 0) && (limit > 0) && (this._virtualStart > 0); i--) {
            adjustNeeded = true;
            size = this._physicalSizes[i] || this._physicalAverage;
            this._physicalOffset += size;
            limit -= size;
            console.log(this._scrollTop, 'flip up at', this._virtualStart, size, limit);
            this.changeIndex(-1);
          }
        }
      }

      // Reset viewport height and adjust offset
      var lastHeight = this._viewportHeight;
      this._viewportHeight = this._physicalAverage * this._virtualCount;
      deltaHeight = this._viewportHeight - lastHeight;
      if (deltaHeight) {
        if (this._pagePosBasis == 'bottom') {
          this._physicalOffset += deltaHeight;
        }
        adjustNeeded = true;
      }

      // if (this.stickyDivider) {
      //   this.stickyDivider.style.top = (this._scrollTop - this._physicalOffset) + 'px';
      // }

      if (adjustNeeded || force) {
        // Re-assign data
        var group = this.groups && this._groupStart;
        var index = this._groupStartIndex;
        for (i = 0; i < this._physicalCount; ++i) {
          this.updateItem(i, group, index, this._virtualStart + i);
          index++;
          if (this.groups && group < this.groups.length - 1) {
            if (index >= this.getGroupLen(group)) {
              index = 0;
              group++;
            }
          }
        }
        // Position page (bindings are used for positioning so offset shift & 
        // data shift happen in same frame on polyfill)
        if (this._pagePosBasis == 'top') {
          this._pageTop = this._physicalOffset + 'px';
          this._pageBottom = 'auto';
        } else {
          this._pageTop = 'auto';
          this._pageBottom = this._physicalOffset + 'px';
        }
      }
    },

    // list selection
    tapHandler: function(e) {
      var n = e.target;
      var p = e.path;
      if (!this.selectionEnabled || (n === this)) {
        return;
      }
      requestAnimationFrame(function() {
        // Gambit: only select the item if the tap wasn't on a focusable child
        // of the list (since anything with its own action should be focusable
        // and not result in result in list selection).  To check this, we
        // asynchronously check that shadowRoot.activeElement is null, which 
        // means the tapped item wasn't focusable. On polyfill where
        // activeElement doesn't follow the data-hinding part of the spec, we
        // can check that document.activeElement is the list itself, which will
        // catch focus in lieu of the tapped item being focusable, as we make
        // the list focusable (tabindex="-1") for this purpose.  Note we also
        // allow the list items themselves to be focusable if desired, so those
        // are excluded as well.
        var active = window.ShadowDOMPolyfill ? 
            wrap(document.activeElement) : this.shadowRoot.activeElement;
        if (active && (active != this) && (active.parentElement != this) && 
            (document.activeElement != document.body)) {
          return;
        }
        // Unfortunately, Safari does not focus certain form controls via mouse,
        // so we also blacklist input, button, & select
        // (https://bugs.webkit.org/show_bug.cgi?id=118043)
        if ((p[0].localName == 'input') || 
            (p[0].localName == 'button') || 
            (p[0].localName == 'select')) {
          return;
        }

        var model = n.templateInstance && n.templateInstance.model;
        if (model) {
          var vi = model.index, pi = model.physicalIndex;
          var data = this.data[vi], item = this._physicalItems[pi];
          this.$.selection.select(data);
          this.asyncFire('core-activate', {data: data, item: item});
        }
      }.bind(this));
    },

    selectedHandler: function(e, detail) {
      this.selection = this.$.selection.getSelection();
      var i$ = this.indexesForData(detail.item);
      // TODO(sorvell): we should be relying on selection to store the
      // selected data but we want to optimize for lookup.
      this._selectedData.set(detail.item, detail.isSelected);
      if (i$.physical >= 0) {
        this.updateItem(i$.virtual, i$.physical);
      }
    },

    /**
     * Select the list item at the given index.
     *
     * @method selectItem
     * @param {number} index 
     */
    selectItem: function(index) {
      if (!this.selectionEnabled) {
        return;
      }
      var data = this.data[index];
      if (data) {
        this.$.selection.select(data);
      }
    },

    /**
     * Set the selected state of the list item at the given index.
     *
     * @method setItemSelected
     * @param {number} index 
     * @param {boolean} isSelected 
     */
    setItemSelected: function(index, isSelected) {
      var data = this.data[index];
      if (data) {
        this.$.selection.setItemSelected(data, isSelected);
      }
    },

    indexesForData: function(data) {
      var virtual = this.data.indexOf(data);
      var physical = this.virtualToPhysicalIndex(virtual);
      return { virtual: virtual, physical: physical };
    },

    virtualToPhysicalIndex: function(index) {
      for (var i=0, l=this._physicalData.length; i<l; i++) {
        if (this._physicalData[i].index === index) {
          return i;
        }
      }
      return -1;
    },

    /**
     * Clears the current selection state of the list.
     *
     * @method clearSelection
     */
    clearSelection: function() {
      this._clearSelection();
      this.refresh(true);
    },

    _clearSelection: function() {
      this._selectedData = new WeakMap();
      this.$.selection.clear();
      this.selection = this.$.selection.getSelection();
    },

    scrollToItem: function(index) {
      this.scrollTop = index * this.height;
    }

  });

})();
</script>
</polymer-element>
